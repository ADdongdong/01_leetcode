#ifndef GREEDY_ALGORITHM_H_INCLUDED
#define GREEDY_ALGORITHM_H_INCLUDED
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

/*1 分发饼干
 *假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
 *对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；
 *并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，
 *个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

 *示例 1:
 *输入: g = [1,2,3], s = [1,1]
 *输出: 1 解释:你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
 *             虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
 *             所以你应该输出1。
 *示例 2:
 *输入: g = [1,2], s = [1,2,3]
 *输出: 2
 *解释:你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
 *你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2.
 *
 *思路：
 *大饼干可以满足大胃口的孩子和小胃口的孩子，
 *小饼干只能满足小胃口的孩子。
 *所以，为了能让更多的小朋友被满足，所以，要让最大的饼干去满足胃口最大的孩子。
 *如果满足不了，就满足胃口次之的孩子，然后，依次类推。
 */
int findContentChildren(vector<int>& g, vector<int>& s) {
    //对孩子列表和饼干列表进行排序
    sort(g.begin(), g.end());
    sort(s.begin(), s.end());
    int num = 0;//定义num就是最大可以满足的孩子的数量
    //然后遍历饼干列表，如果s[i] > g[j] 那么就num+1，i++,j++，不然就j++
    int i = g.size()-1;
    int j = s.size()-1;
    while (i >= 0 && j >= 0){
        //这种写法可以发现，无论饼干是否满足当前孩子，孩子的下标都是要移动的
        //因此，可以以孩子下标为循环变量写出for循环
        if (s[j] >= g[i]){
            //如果当前饼干能满足当前孩子的胃口，那么就继续检查下一个饼干和下一个孩子
            num++;
            i--;
            j--;
        }else {
            //如果当前饼干不能满足当前孩子，说明当前孩子胃口太大，只能检查下一个孩子
            i--;
        }
    }
    /*另一种写法
    int index = s.size() -1;//定义饼干的下标
    int result = 0;//定义最终的结果
    for (int i = g.size() - 1; i >= 0; i--) {
        if (index >=0 && s[index] >= g[i]) {
            result++;
            index--;
        }
    }*/
    return num;
}

/*2 摆动序列
 *给定一个整数序列，返回:作为摆动序列的最长子序列的长度。
 *摆动序列是什么？
 *如果连续数字之间的差严格地在正数和负数之间交替，就称作摆动序列。第一个差可能是正数或负数。
 *如何获得一个序列的摆动序列？
 *通过删除或不删除原始序列中的一些元素，来获得子序列，使得这个子序列是摆动序列。

 *思路：
 *摆动序列有什么特点:a1>a2, a2<a3, a3>a4...数组元素的大小关系必须是大于小于交替出现的。
 *所以，对于给定的序列，要想让其称为摆动序列，就要避免出现连续的>或者<，也要避免出现=。
 *因此，我们在统计子序列长度的时候，如果有一个>，只需要往后找，找后面最近的一对<就行。
 *如果，只有一个>说明子序列长度为2，如果有个>还有个<说明子序列长度为3
 */
int wiggleMaxLength(vector<int>& nums) {
    //如果给定数组中元素只有一个，那么这就是最大的摆动序列
    if (nums.size() <= 1) return nums.size();
    int curDiff = 0;// 当前一对的差值
    int preDiff = 0;// 前一对差值
    int result = 1;// 记录峰值个数，序列默认序列最右边有一个峰值
    //以内循环体内是有i+1的，所以，i的上限就是nums.size()-1
    for (int i = 0; i < nums.size() - 1; i++) {
        curDiff = nums[i + 1] - nums[i];// 记录当前的差值
        // 出现峰值
        // 这里写成preDiff<=0其实，只有当nums只有两个结点的时候会触发等于号
        // 如果没有=那么两个结点的nums只会返回0
        // 如果一个nums = {1,2} 加上等于号，相当于给num前面加上了一个1
        // 这个=不会影响到后面的的元素的，因为curDiff >0 或curDiff <0 注意，这里都是没有等于号的
        // 并且，这个curDiff其实就是下一个cur的pre
        if ((preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0)) {
            result++;
            preDiff = curDiff;// 只在摆出现变化的时候更新prediff
        }
    }
    return result;
}

/*3 最大子序和
 *给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
    示例:
 *输入: [-2,1,-3,4,-1,2,1,-5,4]
 *输出: 6
 *解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
 *
 *思路：
 *连续的子序列之和，对子序列的长度没有限制，就是最少得包含一个元素。
 *贪心算法采取局部最优化的策略。定义一个count记录当前连续自序列的总和，当这个总和小于0的时候，就抛弃当前count.
 *从i+1重新开始求新的子序列的和。
 *因为，如果，当前子序列和都为0了，无论后面那个数字有多大，加上负数都会变小。
 */
int maxSubArray(vector<int>& nums) {
    int result = INT32_MIN;
    int Count = 0;
    for (int i = 0; i < nums.size(); i++) {
        Count += nums[i];
        if (Count > result){
            result = Count;
        }
        if (Count < 0) {
            Count = 0;
        }
    }
    return result;
}
#endif // GREEDY_ALGORITHM_H_INCLUDED
